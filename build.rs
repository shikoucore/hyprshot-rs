use std::env;
use std::path::PathBuf;
use std::process::Command;

fn main() {
    println!("cargo:rerun-if-changed=vendor/slurp");
    
    // Проверяем наличие необходимых инструментов
    if !check_command("meson") {
        eprintln!("Warning: meson not found. Slurp will not be embedded.");
        eprintln!("Install it with: pacman -S meson (Arch) or equivalent");
        eprintln!("Falling back to system slurp dependency.");
        return;
    }
    
    if !check_command("ninja") {
        eprintln!("Warning: ninja not found. Slurp will not be embedded.");
        eprintln!("Install it with: pacman -S ninja (Arch) or equivalent");
        eprintln!("Falling back to system slurp dependency.");
        return;
    }
    
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let slurp_src = PathBuf::from("vendor/slurp");
    
    // Проверяем что submodule инициализирован
    if !slurp_src.join("meson.build").exists() {
        eprintln!("Warning: slurp submodule not initialized.");
        eprintln!("Run: git submodule update --init --recursive");
        eprintln!("Falling back to system slurp dependency.");
        return;
    }
    
    let build_dir = out_dir.join("slurp-build");
    
    println!("Building embedded slurp...");
    
    // Компилируем slurp
    if !build_dir.exists() {
        std::fs::create_dir_all(&build_dir).unwrap();
        
        // Настройка meson
        let status = Command::new("meson")
            .arg("setup")
            .arg(&build_dir)
            .arg(&slurp_src)
            .arg("--prefix=/usr")
            .arg("--buildtype=release")
            .status()
            .expect("Failed to run meson setup");
        
        if !status.success() {
            panic!("Meson setup failed. Check that all dependencies are installed.");
        }
    }
    
    // Компиляция
    let status = Command::new("ninja")
        .arg("-C")
        .arg(&build_dir)
        .status()
        .expect("Failed to run ninja");
    
    if !status.success() {
        panic!("Ninja build failed. Check build output above.");
    }
    
    // Копируем бинарник в OUT_DIR
    let slurp_binary = build_dir.join("slurp");
    if !slurp_binary.exists() {
        panic!("Slurp binary not found at: {}", slurp_binary.display());
    }
    
    let target_binary = out_dir.join("slurp");
    std::fs::copy(&slurp_binary, &target_binary)
        .expect("Failed to copy slurp binary");
    
    println!("Slurp built successfully at: {}", target_binary.display());
    
    // Генерируем Rust код для включения бинарника
    let embed_code = r#"// Auto-generated by build.rs
// This file contains the embedded slurp binary

#[cfg(target_os = "linux")]
pub const EMBEDDED_SLURP: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/slurp"));

#[cfg(not(target_os = "linux"))]
pub const EMBEDDED_SLURP: &[u8] = &[];
"#;
    
    let embed_file = out_dir.join("embedded_slurp.rs");
    std::fs::write(&embed_file, embed_code)
        .expect("Failed to write embedded_slurp.rs");
    
    println!("cargo:rustc-env=SLURP_EMBEDDED=1");
}

fn check_command(cmd: &str) -> bool {
    Command::new(cmd)
        .arg("--version")
        .output()
        .is_ok()
}
