use anyhow::{ Context, Result };
use std::path::PathBuf;
use std::process::Command;

// Include the embedded binary (generated by build.rs).
include!(concat!(env!("OUT_DIR"), "/embedded_slurp.rs"));

/// Returns the path to the slurp executable.
/// Priority: system slurp > embedded slurp.
pub fn get_slurp_path() -> Result<PathBuf> {
    if Command::new("slurp").arg("--version").output().is_ok() {
        return Ok(PathBuf::from("slurp"));
    }

    if EMBEDDED_SLURP.is_empty() {
        anyhow::bail!(
            "Slurp not found in system PATH and embedded slurp is not available.\n\
             Please install slurp: pacman -S slurp (Arch) or equivalent"
        );
    }

    let cache_dir = dirs::cache_dir().context("Failed to get cache directory")?.join("hyprshot-rs");

    std::fs::create_dir_all(&cache_dir).context("Failed to create cache directory")?;

    let slurp_path = cache_dir.join("slurp");

    if !slurp_path.exists() || needs_update(&slurp_path)? {
        extract_slurp(&slurp_path)?;
    }

    Ok(slurp_path)
}

fn extract_slurp(target_path: &PathBuf) -> Result<()> {
    std::fs::write(target_path, EMBEDDED_SLURP).context("Failed to write embedded slurp binary")?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs
            ::set_permissions(target_path, std::fs::Permissions::from_mode(0o755))
            .context("Failed to set executable permissions")?;
    }

    Ok(())
}

/// Checks whether the embedded slurp needs to be refreshed.
fn needs_update(slurp_path: &PathBuf) -> Result<bool> {
    let metadata = std::fs::metadata(slurp_path)?;
    Ok(metadata.len() != (EMBEDDED_SLURP.len() as u64))
}
