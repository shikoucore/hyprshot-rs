use anyhow::{Context, Result};
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use std::io::{Read, Write};
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::{Duration, SystemTime};

// Include the embedded binary (generated by build.rs).
include!(concat!(env!("OUT_DIR"), "/embedded_slurp.rs"));

/// Returns the path to the slurp executable.
/// Priority: system slurp > embedded slurp.
pub fn get_slurp_path() -> Result<PathBuf> {
    if Command::new("slurp").arg("--version").output().is_ok() {
        return Ok(PathBuf::from("slurp"));
    }

    if EMBEDDED_SLURP.is_empty() {
        anyhow::bail!(
            "Slurp not found in system PATH and embedded slurp is not available.\n\
             Please install slurp: pacman -S slurp (Arch) or equivalent"
        );
    }

    let cache_dir = dirs::cache_dir()
        .context("Failed to get cache directory")?
        .join("hyprshot-rs");

    std::fs::create_dir_all(&cache_dir).context("Failed to create cache directory")?;

    let slurp_path = cache_dir.join("slurp");

    let _lock = acquire_lock(&cache_dir)?;
    if !slurp_path.exists() || needs_update(&slurp_path)? {
        extract_slurp(&slurp_path)?;
    }

    Ok(slurp_path)
}

fn extract_slurp(target_path: &PathBuf) -> Result<()> {
    let tmp_path = target_path.with_extension("tmp");
    let mut tmp_file =
        std::fs::File::create(&tmp_path).context("Failed to create temp slurp file")?;
    tmp_file
        .write_all(EMBEDDED_SLURP)
        .context("Failed to write embedded slurp binary")?;
    tmp_file
        .sync_all()
        .context("Failed to sync embedded slurp binary")?;

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(&tmp_path, std::fs::Permissions::from_mode(0o755))
            .context("Failed to set executable permissions")?;
    }

    std::fs::rename(&tmp_path, target_path).context("Failed to replace slurp binary")?;

    Ok(())
}

/// Checks whether the embedded slurp needs to be refreshed.
fn needs_update(slurp_path: &PathBuf) -> Result<bool> {
    if !slurp_path.exists() {
        return Ok(true);
    }

    let embedded_hash = hash_bytes(EMBEDDED_SLURP);
    let file_hash = hash_file(slurp_path)?;
    Ok(file_hash != embedded_hash)
}

fn hash_bytes(bytes: &[u8]) -> u64 {
    let mut hasher = DefaultHasher::new();
    bytes.hash(&mut hasher);
    hasher.finish()
}

fn hash_file(path: &Path) -> Result<u64> {
    let mut file = std::fs::File::open(path).context("Failed to open slurp binary")?;
    let mut hasher = DefaultHasher::new();
    let mut buffer = [0u8; 8192];
    loop {
        let read = file.read(&mut buffer).context("Failed to read slurp binary")?;
        if read == 0 {
            break;
        }
        buffer[..read].hash(&mut hasher);
    }
    Ok(hasher.finish())
}

struct LockGuard {
    path: PathBuf,
}

impl Drop for LockGuard {
    fn drop(&mut self) {
        let _ = std::fs::remove_file(&self.path);
    }
}

fn acquire_lock(dir: &Path) -> Result<LockGuard> {
    let lock_path = dir.join("slurp.lock");
    let start = SystemTime::now();
    let max_wait = Duration::from_secs(10);

    loop {
        match std::fs::OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&lock_path)
        {
            Ok(mut file) => {
                let _ = writeln!(file, "pid={}", std::process::id());
                return Ok(LockGuard { path: lock_path });
            }
            Err(_) => {
                if let Ok(metadata) = std::fs::metadata(&lock_path) {
                    if let Ok(modified) = metadata.modified() {
                        if let Ok(age) = modified.elapsed() {
                            if age > Duration::from_secs(30) {
                                let _ = std::fs::remove_file(&lock_path);
                                continue;
                            }
                        }
                    }
                }
                if start.elapsed().unwrap_or(Duration::from_secs(0)) > max_wait {
                    return Err(anyhow::anyhow!(
                        "Timed out waiting for slurp lock: {}",
                        lock_path.display()
                    ));
                }
                std::thread::sleep(Duration::from_millis(50));
            }
        }
    }
}
